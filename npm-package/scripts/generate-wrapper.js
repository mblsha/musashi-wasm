#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { build as esbuildBuild } from 'esbuild';
import { generateDtsBundle } from 'dts-bundle-generator';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Ensure directories exist
const libDir = path.join(__dirname, '..', 'lib');
const distDir = path.join(__dirname, '..', 'dist');
const packageRootDir = path.join(__dirname, '..');
const repoRootDir = path.join(packageRootDir, '..');

if (!fs.existsSync(libDir)) {
  fs.mkdirSync(libDir, { recursive: true });
}
if (!fs.existsSync(distDir)) {
  fs.mkdirSync(distDir, { recursive: true });
}

function copyDirRecursive(srcDir, destDir) {
  if (!fs.existsSync(srcDir)) {
    throw new Error(`Source directory not found: ${srcDir}`);
  }

  fs.rmSync(destDir, { recursive: true, force: true });
  fs.mkdirSync(destDir, { recursive: true });

  for (const entry of fs.readdirSync(srcDir, { withFileTypes: true })) {
    const srcPath = path.join(srcDir, entry.name);
    const destPath = path.join(destDir, entry.name);

    if (entry.isDirectory()) {
      copyDirRecursive(srcPath, destPath);
    } else if (entry.isSymbolicLink()) {
      // Skip symlinks to avoid packaging broken references (the ESM variants cover our needs).
      continue;
    } else {
      fs.copyFileSync(srcPath, destPath);
    }
  }
}

async function bundleCoreRuntime() {
  const coreOutDir = path.join(libDir, 'core');
  fs.rmSync(coreOutDir, { recursive: true, force: true });
  fs.mkdirSync(coreOutDir, { recursive: true });

  const coreEntry = path.join(repoRootDir, 'packages', 'core', 'src', 'index.ts');
  const commonEntry = path.join(repoRootDir, 'packages', 'common', 'src', 'index.ts');

  await esbuildBuild({
    entryPoints: [coreEntry],
    outfile: path.join(coreOutDir, 'index.js'),
    bundle: true,
    format: 'esm',
    platform: 'neutral',
    target: ['es2020'],
    absWorkingDir: repoRootDir,
    logLevel: 'silent',
    plugins: [
      {
        name: 'musashi-wasm-alias',
        setup(build) {
          build.onResolve({ filter: /^@m68k\/common$/ }, () => ({
            path: commonEntry,
          }));
          build.onResolve({ filter: /^musashi-wasm\/node$/ }, () => ({
            path: 'musashi-wasm/node',
            external: true,
          }));
          build.onResolve({ filter: /^\.\.\/wasm\/musashi-node-wrapper\.mjs$/ }, args => ({
            path: args.path,
            external: true,
          }));
        },
      },
    ],
  });

  const [coreDts] = generateDtsBundle([
    {
      filePath: coreEntry,
      output: {
        noBanner: true,
      },
      libraries: {
        inlinedLibraries: ['@m68k/common'],
      },
      compilerOptions: {
        baseUrl: path.join(repoRootDir, 'packages'),
        paths: {
          '@m68k/common': ['common/src/index.ts'],
        },
      },
    },
  ]);

  fs.writeFileSync(path.join(coreOutDir, 'index.d.ts'), `${coreDts.trimEnd()}\n`);

  return coreOutDir;
}

async function bundleMemoryHelpers() {
  const memoryOutDir = path.join(libDir, 'memory');
  fs.rmSync(memoryOutDir, { recursive: true, force: true });
  fs.mkdirSync(memoryOutDir, { recursive: true });

  const memoryEntry = path.join(repoRootDir, 'packages', 'memory', 'src', 'index.ts');

  await esbuildBuild({
    entryPoints: [memoryEntry],
    outfile: path.join(memoryOutDir, 'index.js'),
    bundle: true,
    format: 'esm',
    platform: 'neutral',
    target: ['es2020'],
    absWorkingDir: repoRootDir,
    logLevel: 'silent',
  });

  const [memoryDts] = generateDtsBundle([
    {
      filePath: memoryEntry,
      output: {
        noBanner: true,
      },
      compilerOptions: {
        baseUrl: path.join(repoRootDir, 'packages'),
      },
    },
  ]);

  const header = `// AUTO-GENERATED by npm-package/scripts/generate-wrapper.js\n// Source: packages/memory/src/index.ts\n// Regenerate with: npm --prefix npm-package run build\n\n`;

  const jsOutPath = path.join(memoryOutDir, 'index.js');
  const rawJs = fs.readFileSync(jsOutPath, 'utf8');
  fs.writeFileSync(jsOutPath, `${header}${rawJs}`);

  fs.writeFileSync(
    path.join(memoryOutDir, 'index.d.ts'),
    `${header}${memoryDts.trimEnd()}\n`
  );

  return memoryOutDir;
}

function stageCoreAssets(coreOutDir) {
  const wasmCandidates = [
    path.join(repoRootDir, 'packages', 'core', 'wasm'),
    path.join(packageRootDir, 'node_modules', '@m68k', 'core', 'wasm'),
  ];
  const wasmSrc = wasmCandidates.find(p => fs.existsSync(p));
  if (!wasmSrc) {
    console.warn('⚠️  packages/core/wasm directory not found; skipping musashi-node wrapper stage.');
    return;
  }

  const wasmOutDir = path.join(libDir, 'wasm');
  copyDirRecursive(wasmSrc, wasmOutDir);

  const wrapperPath = path.join(wasmOutDir, 'musashi-node-wrapper.mjs');
  if (fs.existsSync(wrapperPath)) {
    let wrapperSrc = fs.readFileSync(wrapperPath, 'utf8');
    wrapperSrc = wrapperSrc.replace(/from\s+(['"])(\.{1,2}\/.*musashi-node\.out\.mjs)\1/g, "from 'musashi-wasm/node'");
    fs.writeFileSync(wrapperPath, wrapperSrc);
  }
}

// Generate CommonJS wrapper for standard build (kept for completeness; not exported)
const cjsWrapper = `const fs = require('fs');
const path = require('path');

let Module = null;
let modulePromise = null;

function loadMusashi() {
  if (modulePromise) return modulePromise;
  
  modulePromise = new Promise(async (resolve, reject) => {
    try {
      const wasmPath = path.join(__dirname, '..', 'dist', 'musashi.wasm');
      const wasmBuffer = fs.readFileSync(wasmPath);
      
      // Create module configuration
      const moduleConfig = {
        wasmBinary: wasmBuffer,
        onRuntimeInitialized: function() {
          Module = this;
          resolve(this);
        }
      };
      
      // Load the emscripten-generated module
      const mod = require('../dist/musashi-loader.cjs');
      const EmscriptenModule = (mod && (mod.default || mod));
      EmscriptenModule(moduleConfig);
    } catch (error) {
      reject(error);
    }
  });
  
  return modulePromise;
}

class Musashi {
  constructor() {
    this.module = null;
    this.initialized = false;
  }
  
  async init() {
    if (this.initialized) return;
    this.module = await loadMusashi();
    this.module._m68k_init();
    this.initialized = true;
  }
  
  // CPU Control
  execute(cycles) {
    return this.module._m68k_execute(cycles);
  }
  
  pulseReset() {
    this.module._m68k_pulse_reset();
  }
  
  cyclesRun() {
    return this.module._m68k_cycles_run();
  }
  
  // Register Access
  getReg(reg) {
    return this.module._m68k_get_reg(null, reg);
  }
  
  setReg(reg, value) {
    this.module._m68k_set_reg(reg, value);
  }
  
  // Memory Management
  addRegion(base, size, dataPtr) {
    return this.module._add_region(base, size, dataPtr);
  }
  
  clearRegions() {
    this.module._clear_regions();
  }
  
  // Callbacks
  setReadMemFunc(func) {
    const ptr = this.module.addFunction(func, 'ii');
    this.module._set_read_mem_func(ptr);
    return ptr;
  }
  
  setWriteMemFunc(func) {
    const ptr = this.module.addFunction(func, 'vii');
    this.module._set_write_mem_func(ptr);
    return ptr;
  }
  
  setPCHookFunc(func) {
    const ptr = this.module.addFunction(func, 'ii');
    this.module._set_pc_hook_func(ptr);
    return ptr;
  }
  
  removeFunction(ptr) {
    this.module.removeFunction(ptr);
  }
  
  // Memory Access
  allocateMemory(size) {
    return this.module._malloc(size);
  }
  
  freeMemory(ptr) {
    this.module._free(ptr);
  }
  
  writeMemory(ptr, data) {
    this.module.HEAPU8.set(data, ptr);
  }
  
  readMemory(ptr, size) {
    return new Uint8Array(this.module.HEAPU8.buffer, ptr, size);
  }
  
  // Debug
  enablePrintfLogging(enable) {
    this.module._enable_printf_logging(enable ? 1 : 0);
  }
}

module.exports = Musashi;
module.exports.Musashi = Musashi;
module.exports.default = Musashi;
`;

// Generate ESM wrapper for standard build (Node + Browser)
const esmWrapper = `const detectRuntime = () => {
  const globalScope = globalThis;
  const isBrowser =
    typeof globalScope.importScripts === 'function' ||
    typeof globalScope.navigator === 'object' ||
    'document' in globalScope ||
    'window' in globalScope;
  const isNode =
    typeof globalScope.process !== 'undefined' &&
    globalScope.process?.release?.name === 'node';
  return isNode && !isBrowser ? 'node' : 'browser';
};

const runtime = detectRuntime();

let Module = null;
let modulePromise = null;

async function instantiateNode() {
  const [{ default: createModule }, { fileURLToPath }] = await Promise.all([
    import('../dist/musashi-loader.mjs'),
    import('url')
  ]);
  const wasmUrl = new URL('../dist/musashi.wasm', import.meta.url);
  const wasmPath = fileURLToPath(wasmUrl);
  return createModule({
    locateFile(path) {
      return path.endsWith('.wasm') ? wasmPath : path;
    }
  });
}

async function instantiateBrowser() {
  const { default: createModule } = await import('../musashi.out.mjs');
  return createModule();
}

async function loadMusashi() {
  if (Module) return Module;

  if (!modulePromise) {
    modulePromise = (async () => {
      const instantiatedModule = runtime === 'node'
        ? await instantiateNode()
        : await instantiateBrowser();
      Module = instantiatedModule;
      return instantiatedModule;
    })();

    modulePromise.catch(() => {
      modulePromise = null;
    });
  }

  return modulePromise;
}

export class Musashi {
  constructor() {
    this.module = null;
    this.initialized = false;
  }
  
  async init() {
    if (this.initialized) return;
    this.module = await loadMusashi();
    this.module._m68k_init();
    this.initialized = true;
  }
  
  // CPU Control
  execute(cycles) {
    return this.module._m68k_execute(cycles);
  }
  
  pulseReset() {
    this.module._m68k_pulse_reset();
  }
  
  cyclesRun() {
    return this.module._m68k_cycles_run();
  }
  
  // Register Access
  getReg(reg) {
    return this.module._m68k_get_reg(null, reg);
  }
  
  setReg(reg, value) {
    this.module._m68k_set_reg(reg, value);
  }
  
  // Memory Management
  addRegion(base, size, dataPtr) {
    return this.module._add_region(base, size, dataPtr);
  }
  
  clearRegions() {
    this.module._clear_regions();
  }
  
  // Callbacks
  setReadMemFunc(func) {
    const ptr = this.module.addFunction(func, 'ii');
    this.module._set_read_mem_func(ptr);
    return ptr;
  }
  
  setWriteMemFunc(func) {
    const ptr = this.module.addFunction(func, 'vii');
    this.module._set_write_mem_func(ptr);
    return ptr;
  }
  
  setPCHookFunc(func) {
    const ptr = this.module.addFunction(func, 'ii');
    this.module._set_pc_hook_func(ptr);
    return ptr;
  }
  
  removeFunction(ptr) {
    this.module.removeFunction(ptr);
  }
  
  // Memory Access
  allocateMemory(size) {
    return this.module._malloc(size);
  }
  
  freeMemory(ptr) {
    this.module._free(ptr);
  }
  
  writeMemory(ptr, data) {
    this.module.HEAPU8.set(data, ptr);
  }
  
  readMemory(ptr, size) {
    return new Uint8Array(this.module.HEAPU8.buffer, ptr, size);
  }
  
  // Debug
  enablePrintfLogging(enable) {
    this.module._enable_printf_logging(enable ? 1 : 0);
  }
}

export { createSystem, M68kRegister } from './core/index.js';
export default Musashi;
`;

// Generate Perfetto-enabled CommonJS wrapper
const perfettoCjsWrapper = `const fs = require('fs');
const path = require('path');

let Module = null;
let modulePromise = null;

function loadMusashiPerfetto() {
  if (modulePromise) return modulePromise;
  
  modulePromise = new Promise((resolve, reject) => {
    try {
      const wasmPath = path.join(__dirname, '..', 'dist', 'musashi-perfetto.wasm');
      const wasmBuffer = fs.readFileSync(wasmPath);
      
      const moduleConfig = {
        wasmBinary: wasmBuffer,
        onRuntimeInitialized: function() {
          Module = this;
          resolve(this);
        }
      };
      
      const EmscriptenModule = require('../dist/musashi-perfetto-loader.cjs');
      EmscriptenModule(moduleConfig);
    } catch (error) {
      reject(error);
    }
  });
  
  return modulePromise;
}

class MusashiPerfetto {
  constructor() {
    this.module = null;
    this.initialized = false;
  }
  
  async init(processName = 'Musashi') {
    if (this.initialized) return;
    this.module = await loadMusashiPerfetto();
    this.module._m68k_init();
    
    // Initialize Perfetto
    const namePtr = this.module.allocateUTF8(processName);
    this.module._m68k_perfetto_init(namePtr);
    this.module._free(namePtr);
    
    this.initialized = true;
  }
  
  // All standard Musashi methods...
  execute(cycles) {
    return this.module._m68k_execute(cycles);
  }
  
  pulseReset() {
    this.module._m68k_pulse_reset();
  }
  
  cyclesRun() {
    return this.module._m68k_cycles_run();
  }
  
  getReg(reg) {
    return this.module._m68k_get_reg(null, reg);
  }
  
  setReg(reg, value) {
    this.module._m68k_set_reg(reg, value);
  }
  
  addRegion(base, size, dataPtr) {
    return this.module._add_region(base, size, dataPtr);
  }
  
  clearRegions() {
    this.module._clear_regions();
  }
  
  setReadMemFunc(func) {
    const ptr = this.module.addFunction(func, 'ii');
    this.module._set_read_mem_func(ptr);
    return ptr;
  }
  
  setWriteMemFunc(func) {
    const ptr = this.module.addFunction(func, 'vii');
    this.module._set_write_mem_func(ptr);
    return ptr;
  }
  
  setPCHookFunc(func) {
    const ptr = this.module.addFunction(func, 'ii');
    this.module._set_pc_hook_func(ptr);
    return ptr;
  }
  
  removeFunction(ptr) {
    this.module.removeFunction(ptr);
  }
  
  allocateMemory(size) {
    return this.module._malloc(size);
  }
  
  freeMemory(ptr) {
    this.module._free(ptr);
  }
  
  writeMemory(ptr, data) {
    this.module.HEAPU8.set(data, ptr);
  }
  
  readMemory(ptr, size) {
    return new Uint8Array(this.module.HEAPU8.buffer, ptr, size);
  }
  
  enablePrintfLogging(enable) {
    this.module._enable_printf_logging(enable ? 1 : 0);
  }
  
  // Perfetto-specific methods
  enableFlowTracing(enable) {
    this.module._m68k_perfetto_enable_flow(enable ? 1 : 0);
  }
  
  enableInstructionTracing(enable) {
    this.module._m68k_perfetto_enable_instructions(enable ? 1 : 0);
  }
  
  enableMemoryTracing(enable) {
    this.module._m68k_perfetto_enable_memory(enable ? 1 : 0);
  }
  
  enableInterruptTracing(enable) {
    this.module._m68k_perfetto_enable_interrupts(enable ? 1 : 0);
  }
  
  async exportTrace() {
    const dataPtrPtr = this.module._malloc(4);
    const sizePtr = this.module._malloc(4);
    
    try {
      this.module._m68k_perfetto_export_trace(dataPtrPtr, sizePtr);
      
      const dataPtr = this.module.getValue(dataPtrPtr, '*');
      const dataSize = this.module.getValue(sizePtr, 'i32');
      
      if (dataPtr === 0 || dataSize === 0) {
        return null;
      }
      
      // Copy trace data from WASM heap
      const traceData = new Uint8Array(dataSize);
      traceData.set(new Uint8Array(this.module.HEAPU8.buffer, dataPtr, dataSize));
      
      // Free the trace data in WASM
      this.module._m68k_perfetto_free_trace_data(dataPtr);
      
      return traceData;
    } finally {
      this.module._free(dataPtrPtr);
      this.module._free(sizePtr);
    }
  }
  
  saveTrace(filename) {
    const traceData = this.exportTrace();
    if (traceData) {
      fs.writeFileSync(filename, traceData);
      return true;
    }
    return false;
  }
}

module.exports = MusashiPerfetto;
module.exports.MusashiPerfetto = MusashiPerfetto;
module.exports.default = MusashiPerfetto;
`;

// Ensure expected Emscripten loader+wasm are present under dist/
const rootDir = packageRootDir;
const altRootDir = repoRootDir;
const nodeJsCandidates = [
  path.join(rootDir, 'musashi-node.out.mjs'),
  path.join(altRootDir, 'musashi-node.out.mjs')
];
const nodeWasmCandidates = [
  path.join(rootDir, 'musashi-node.out.wasm'),
  path.join(altRootDir, 'musashi-node.out.wasm')
];
const nodeWasmMapCandidates = [
  path.join(rootDir, 'musashi-node.out.wasm.map'),
  path.join(altRootDir, 'musashi-node.out.wasm.map')
];
const loaderOut = path.join(distDir, 'musashi-loader.mjs');
const wasmOut = path.join(distDir, 'musashi.wasm');
const wasmMapOut = path.join(distDir, 'musashi.wasm.map');
const nodeModuleOut = path.join(rootDir, 'musashi-node.out.mjs');
const nodeWasmOut = path.join(rootDir, 'musashi-node.out.wasm');
const nodeWasmMapOut = path.join(rootDir, 'musashi-node.out.wasm.map');

const browserJsCandidates = [
  path.join(rootDir, 'musashi.out.mjs'),
  path.join(altRootDir, 'musashi.out.mjs')
];
const browserWasmCandidates = [
  path.join(rootDir, 'musashi.out.wasm'),
  path.join(altRootDir, 'musashi.out.wasm')
];
const browserWasmMapCandidates = [
  path.join(rootDir, 'musashi.out.wasm.map'),
  path.join(altRootDir, 'musashi.out.wasm.map')
];
const browserModuleOut = path.join(rootDir, 'musashi.out.mjs');
const browserWasmOut = path.join(rootDir, 'musashi.out.wasm');
const browserWasmMapOut = path.join(rootDir, 'musashi.out.wasm.map');

const nodeJsIn = nodeJsCandidates.find(p => fs.existsSync(p));
const nodeWasmIn = nodeWasmCandidates.find(p => fs.existsSync(p));
const nodeWasmMapIn = nodeWasmMapCandidates.find(p => fs.existsSync(p));

if (!nodeJsIn || !nodeWasmIn) {
  throw new Error('Missing musashi-node build artifacts. Run `./build.sh` before packaging.');
}

const nodeJsSource = fs.readFileSync(nodeJsIn, 'utf8');
const perfettoSymbol = '_m68k_perfetto_init';
if (!nodeJsSource.includes(perfettoSymbol)) {
  throw new Error(
    'musashi-node.out.mjs does not include Perfetto exports. Rebuild with `ENABLE_PERFETTO=1 ./build.sh` before packaging.'
  );
}

fs.copyFileSync(nodeJsIn, loaderOut);
if (nodeJsIn !== nodeModuleOut) {
  fs.copyFileSync(nodeJsIn, nodeModuleOut);
}

fs.copyFileSync(nodeWasmIn, wasmOut);
if (nodeWasmIn !== nodeWasmOut) {
  fs.copyFileSync(nodeWasmIn, nodeWasmOut);
}

if (nodeWasmMapIn) {
  fs.copyFileSync(nodeWasmMapIn, wasmMapOut);
  if (nodeWasmMapIn !== nodeWasmMapOut) {
    fs.copyFileSync(nodeWasmMapIn, nodeWasmMapOut);
  }
} else {
  // Remove stale maps if previous builds produced them.
  [wasmMapOut, nodeWasmMapOut].forEach(target => {
    if (fs.existsSync(target)) {
      fs.rmSync(target);
    }
  });
}

const perfLoaderOut = path.join(distDir, 'musashi-perfetto-loader.mjs');
const perfWasmOut = path.join(distDir, 'musashi-perfetto.wasm');
if (process.env.ENABLE_PERFETTO === '1') {
  const perfLoaderSource = fs
    .readFileSync(nodeJsIn, 'utf8')
    .replace(/musashi-node\.out\.wasm/g, 'musashi-perfetto.wasm');
  fs.writeFileSync(perfLoaderOut, perfLoaderSource);
  fs.copyFileSync(nodeWasmIn, perfWasmOut);
} else {
  [perfLoaderOut, perfWasmOut].forEach(target => {
    if (fs.existsSync(target)) {
      fs.rmSync(target);
    }
  });
}

const browserJsIn = browserJsCandidates.find(p => fs.existsSync(p));
const browserWasmIn = browserWasmCandidates.find(p => fs.existsSync(p));
const browserWasmMapIn = browserWasmMapCandidates.find(p => fs.existsSync(p));

if (!browserJsIn || !browserWasmIn) {
  throw new Error('Missing musashi browser build artifacts. Run `./build.sh` before packaging.');
}

if (browserJsIn !== browserModuleOut) {
  fs.copyFileSync(browserJsIn, browserModuleOut);
}

if (browserWasmIn !== browserWasmOut) {
  fs.copyFileSync(browserWasmIn, browserWasmOut);
}

if (browserWasmMapIn) {
  if (browserWasmMapIn !== browserWasmMapOut) {
    fs.copyFileSync(browserWasmMapIn, browserWasmMapOut);
  }
} else if (fs.existsSync(browserWasmMapOut)) {
  fs.rmSync(browserWasmMapOut);
}

const coreOutDir = await bundleCoreRuntime();
stageCoreAssets(coreOutDir);
await bundleMemoryHelpers();

// Note: musashi-node.d.ts is committed to the repo and doesn't need regeneration

// Write wrapper files (ESM-only)
fs.writeFileSync(path.join(libDir, 'index.mjs'), esmWrapper);

// Generate ESM wrapper for perfetto (Node + Browser; saveTrace only in Node)
const perfettoEsmWrapper = `const detectRuntime = () => {
  const globalScope = globalThis;
  const isBrowser =
    typeof globalScope.importScripts === 'function' ||
    typeof globalScope.navigator === 'object' ||
    'document' in globalScope ||
    'window' in globalScope;
  const isNode =
    typeof globalScope.process !== 'undefined' &&
    globalScope.process?.release?.name === 'node';
  return isNode && !isBrowser ? 'node' : 'browser';
};

const runtime = detectRuntime();

let Module = null;
let modulePromise = null;

async function instantiateNode() {
  const [{ default: createModule }, { fileURLToPath }] = await Promise.all([
    import('../dist/musashi-perfetto-loader.mjs'),
    import('url')
  ]);
  const wasmUrl = new URL('../dist/musashi-perfetto.wasm', import.meta.url);
  const wasmPath = fileURLToPath(wasmUrl);
  return createModule({
    locateFile(path) {
      return path.endsWith('.wasm') ? wasmPath : path;
    }
  });
}

async function loadMusashiPerfetto() {
  if (Module) return Module;
  if (runtime !== 'node') {
    throw new Error('MusashiPerfetto is only available in Node.js environments.');
  }
  if (!modulePromise) {
    modulePromise = (async () => {
      const instantiatedModule = await instantiateNode();
      Module = instantiatedModule;
      return instantiatedModule;
    })();
    modulePromise.catch(() => {
      modulePromise = null;
    });
  }
  return modulePromise;
}

export class MusashiPerfetto {
  constructor() {
    this.module = null;
    this.initialized = false;
  }
  
  async init(processName = 'Musashi') {
    if (this.initialized) return;
    this.module = await loadMusashiPerfetto();
    this.module._m68k_init();
    
    // Initialize Perfetto
    const namePtr = this.module.allocateUTF8(processName);
    this.module._m68k_perfetto_init(namePtr);
    this.module._free(namePtr);
    
    this.initialized = true;
  }
  
  // All standard Musashi methods...
  execute(cycles) { return this.module._m68k_execute(cycles); }
  pulseReset() { this.module._m68k_pulse_reset(); }
  cyclesRun() { return this.module._m68k_cycles_run(); }
  getReg(reg) { return this.module._m68k_get_reg(null, reg); }
  setReg(reg, value) { this.module._m68k_set_reg(reg, value); }
  addRegion(base, size, dataPtr) { return this.module._add_region(base, size, dataPtr); }
  clearRegions() { this.module._clear_regions(); }
  setReadMemFunc(func) { const ptr = this.module.addFunction(func, 'ii'); this.module._set_read_mem_func(ptr); return ptr; }
  setWriteMemFunc(func) { const ptr = this.module.addFunction(func, 'vii'); this.module._set_write_mem_func(ptr); return ptr; }
  setPCHookFunc(func) { const ptr = this.module.addFunction(func, 'ii'); this.module._set_pc_hook_func(ptr); return ptr; }
  removeFunction(ptr) { this.module.removeFunction(ptr); }
  allocateMemory(size) { return this.module._malloc(size); }
  freeMemory(ptr) { this.module._free(ptr); }
  writeMemory(ptr, data) { this.module.HEAPU8.set(data, ptr); }
  readMemory(ptr, size) { return new Uint8Array(this.module.HEAPU8.buffer, ptr, size); }
  enablePrintfLogging(enable) { this.module._enable_printf_logging(enable ? 1 : 0); }

  // Perfetto-specific methods
  enableFlowTracing(enable) { this.module._m68k_perfetto_enable_flow(enable ? 1 : 0); }
  enableInstructionTracing(enable) { this.module._m68k_perfetto_enable_instructions(enable ? 1 : 0); }
  enableMemoryTracing(enable) { this.module._m68k_perfetto_enable_memory(enable ? 1 : 0); }
  enableInterruptTracing(enable) { this.module._m68k_perfetto_enable_interrupts(enable ? 1 : 0); }

  async exportTrace() {
    const dataPtrPtr = this.module._malloc(4);
    const sizePtr = this.module._malloc(4);
    try {
      this.module._m68k_perfetto_export_trace(dataPtrPtr, sizePtr);
      const dataPtr = this.module.getValue(dataPtrPtr, '*');
      const dataSize = this.module.getValue(sizePtr, 'i32');
      if (dataPtr === 0 || dataSize === 0) return null;
      const traceData = new Uint8Array(dataSize);
      traceData.set(new Uint8Array(this.module.HEAPU8.buffer, dataPtr, dataSize));
      this.module._m68k_perfetto_free_trace_data(dataPtr);
      return traceData;
    } finally {
      this.module._free(dataPtrPtr);
      this.module._free(sizePtr);
    }
  }

  async saveTrace(filename) {
    const isNode = typeof process !== 'undefined' && !!process.versions?.node;
    const traceData = await this.exportTrace();
    if (!traceData) return false;
    if (!isNode) return false;
    const { writeFileSync } = await import('fs');
    writeFileSync(filename, traceData);
    return true;
  }
}

export default MusashiPerfetto;
`;

fs.writeFileSync(path.join(libDir, 'perfetto.mjs'), perfettoEsmWrapper);

console.log('✅ Generated wrapper modules in lib/');
