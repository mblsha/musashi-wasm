name: Publish to npm

on:
  release:
    types: [published]
  workflow_dispatch:

jobs:
  build-and-publish:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout repository at release tag
        uses: actions/checkout@v4
        with:
          submodules: recursive
          ref: ${{ github.event.release.tag_name }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'
          # no cache: avoid missing lockfile issues

      - name: Setup Emscripten
        uses: mymindstorm/setup-emsdk@v14
        with:
          version: '4.0.12'

      - name: Install fish shell
        run: |
          sudo apt-get update
          sudo apt-get install -y fish

      - name: Create package directory
        run: mkdir -p npm-package/dist

      # --- Build Standard WASM ---
      - name: Build standard WASM
        run: ./build_wasm_simple.sh

      - name: Stage standard WASM artifacts
        run: |
          mv musashi-node.out.wasm npm-package/dist/musashi.wasm
          mv musashi-node.out.js   npm-package/dist/musashi-loader.js

      # --- Build Perfetto prerequisites ---
      - name: Build protobuf & abseil for Perfetto
        shell: bash
        run: |
          set -euo pipefail
          chmod +x build_protobuf_wasm.sh build_perfetto_wasm_simple.sh
          ./build_protobuf_wasm.sh
          # Sanity checks
          test -f third_party/protobuf-wasm-install/lib/libprotobuf.a
          ls -1 third_party/abseil-wasm-install/lib/libabsl_*.a | head -n1
          test -f third_party/retrobus-perfetto/cpp/proto/perfetto.pb.cc
          test -f third_party/retrobus-perfetto/cpp/proto/perfetto.pb.h

      # --- Build Perfetto WASM ---
      - name: Build Perfetto WASM
        run: ./build_perfetto_wasm_simple.sh

      - name: Stage Perfetto WASM artifacts
        run: |
          mv musashi-node.out.wasm npm-package/dist/musashi-perfetto.wasm
          mv musashi-node.out.js   npm-package/dist/musashi-perfetto-loader.js

      # --- Generate package.json and entry wrappers (ESM + CJS) ---
      - name: Generate package manifest and wrappers
        shell: bash
        run: |
          set -euo pipefail
          VERSION_RAW='${{ github.event.release.tag_name }}'
          VERSION="${VERSION_RAW#v}"

          cat > npm-package/package.json <<'JSON'
          {
            "name": "musashi-wasm",
            "version": "0.0.0",
            "description": "M68k Musashi WebAssembly (default and Perfetto profiling builds)",
            "license": "MIT",
            "type": "module",
            "exports": {
              ".": {
                "import": "./index.js",
                "require": "./index.cjs"
              },
              "./perf": {
                "import": "./perf.js",
                "require": "./perf.cjs"
              }
            },
            "main": "./index.cjs",
            "module": "./index.js",
            "files": [
              "dist/*",
              "index.js",
              "index.cjs",
              "perf.js",
              "perf.cjs",
              "README.md",
              "LICENSE"
            ],
            "publishConfig": {
              "access": "public",
              "provenance": true
            }
          }
          JSON

          # ESM wrappers (use fileURLToPath for Node ESM; href for web/bundlers)
          cat > npm-package/index.js <<'JS'
          import { fileURLToPath } from "url";
          import createModule from "./dist/musashi-loader.js";
          export default function init(options = {}) {
            const isNode = typeof process !== "undefined" && !!process.versions?.node;
            const wasmUrl = new URL("./dist/musashi.wasm", import.meta.url);
            const wasmPath = isNode ? fileURLToPath(wasmUrl) : wasmUrl.href;
            const locateFile = (p) => p.endsWith(".wasm") ? wasmPath : p;
            return createModule({ locateFile, ...options });
          }
          JS

          cat > npm-package/perf.js <<'JS'
          import { fileURLToPath } from "url";
          import createModule from "./dist/musashi-perfetto-loader.js";
          export default function init(options = {}) {
            const isNode = typeof process !== "undefined" && !!process.versions?.node;
            const wasmUrl = new URL("./dist/musashi-perfetto.wasm", import.meta.url);
            const wasmPath = isNode ? fileURLToPath(wasmUrl) : wasmUrl.href;
            const locateFile = (p) => p.endsWith(".wasm") ? wasmPath : p;
            return createModule({ locateFile, ...options });
          }
          JS

          # CJS wrappers
          cat > npm-package/index.cjs <<'CJS'
          const path = require("path");
          const createModule = require("./dist/musashi-loader.js");
          module.exports = function init(options = {}) {
            const wasmPath = path.join(__dirname, "dist", "musashi.wasm");
            const locateFile = (p) => p.endsWith(".wasm") ? wasmPath : p;
            return createModule({ locateFile, ...options });
          };
          CJS

          cat > npm-package/perf.cjs <<'CJS'
          const path = require("path");
          const createModule = require("./dist/musashi-perfetto-loader.js");
          module.exports = function init(options = {}) {
            const wasmPath = path.join(__dirname, "dist", "musashi-perfetto.wasm");
            const locateFile = (p) => p.endsWith(".wasm") ? wasmPath : p;
            return createModule({ locateFile, ...options });
          };
          CJS

          # Copy docs if present
          [ -f README.md ] && cp README.md npm-package/ || true
          [ -f LICENSE ]   && cp LICENSE   npm-package/ || true

          # Stamp the version from the tag
          npm --prefix npm-package version "$VERSION" --no-git-tag-version

      - name: List final package contents
        run: ls -lR npm-package

      - name: Publish to npm
        working-directory: npm-package
        run: npm publish --access public --provenance
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}