name: Publish to npm (reuse CI artifacts)

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Tag to publish (e.g., v0.1.1)'
        required: true
        type: string

# Prevent concurrent runs that could interfere with each other
concurrency:
  group: npm-publish-${{ github.event.release.tag_name || inputs.tag_name }}
  cancel-in-progress: false

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write   # provenance for npm
      actions: read     # allow reading other runs/artifacts
    env:
      GH_TOKEN: ${{ github.token }}   # for gh CLI
    timeout-minutes: 15  # Prevent hanging workflows

    steps:
      - name: Checkout repo at release tag
        uses: actions/checkout@v4
        with:
          submodules: recursive
          ref: ${{ github.event.release.tag_name || inputs.tag_name }}

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Validate release and tag
        id: validate
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ github.event.release.tag_name || inputs.tag_name }}"
          COMMIT="$(git rev-parse HEAD)"
          
          echo "Tag: $TAG"
          echo "Commit: $COMMIT"
          
          # Validate tag format (should be semantic version)
          if [[ ! "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
            echo "ERROR: Tag '$TAG' does not follow semantic versioning format (v1.2.3 or v1.2.3-alpha.1)"
            exit 1
          fi
          
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "commit=$COMMIT" >> "$GITHUB_OUTPUT"
          
      - name: Wait for and resolve CI run
        id: find_run
        shell: bash
        run: |
          set -euo pipefail
          COMMIT="${{ steps.validate.outputs.commit }}"
          TAG="${{ steps.validate.outputs.tag }}"
          
          echo "Looking for successful WebAssembly CI run for commit: $COMMIT"
          
          # Wait for CI to complete with retries (max 10 minutes)
          MAX_ATTEMPTS=20
          WAIT_SECONDS=30
          
          for attempt in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $attempt/$MAX_ATTEMPTS: Searching for successful CI run..."
            
            # Search for successful runs, increasing limit over time
            SEARCH_LIMIT=$((25 + attempt * 5))
            gh run list --workflow "WebAssembly CI" --json databaseId,headSha,conclusion,event,createdAt --limit $SEARCH_LIMIT > runs.json
            
            # Debug: show what we found
            echo "Found runs for this commit:"
            jq -r --arg sha "$COMMIT" '.[] | select(.headSha==$sha) | "  Run " + (.databaseId|tostring) + ": " + .conclusion + " (" + .event + ")"' runs.json || true
            
            # Look for successful run
            RUN_ID=$(jq -r --arg sha "$COMMIT" '.[] | select(.headSha==$sha and .conclusion=="success") | .databaseId' runs.json | head -n1)
            
            if [ -n "$RUN_ID" ] && [ "$RUN_ID" != "null" ]; then
              echo "‚úÖ Found successful CI run: $RUN_ID"
              echo "run_id=$RUN_ID" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            
            # Check if there are any failed runs
            FAILED_COUNT=$(jq -r --arg sha "$COMMIT" '[.[] | select(.headSha==$sha and .conclusion=="failure")] | length' runs.json)
            if [ "$FAILED_COUNT" -gt 0 ]; then
              echo "‚ö†Ô∏è  Found $FAILED_COUNT failed CI run(s) for this commit"
            fi
            
            if [ $attempt -lt $MAX_ATTEMPTS ]; then
              echo "No successful run found yet, waiting ${WAIT_SECONDS}s before retry..."
              sleep $WAIT_SECONDS
            fi
          done
          
          echo "‚ùå TIMEOUT: No successful 'WebAssembly CI' run found for commit $COMMIT after $MAX_ATTEMPTS attempts"
          echo "Please check:"
          echo "  1. WebAssembly CI workflow is configured to run on tags (v*)"
          echo "  2. The CI run completed successfully"
          echo "  3. Artifacts are being retained (retention-days > 0)"
          echo "  4. There are no failures in the WebAssembly CI workflow"
          exit 1

      - name: Download and verify CI artifacts
        shell: bash
        run: |
          set -euo pipefail
          RUN_ID="${{ steps.find_run.outputs.run_id }}"
          mkdir -p ci-artifacts
          
          echo "üì¶ Downloading artifacts from CI run: $RUN_ID"
          
          # List available artifacts first for debugging
          echo "Available artifacts for this run:"
          gh run view "$RUN_ID" --json artifacts --jq '.artifacts[] | "  " + .name + " (" + (.sizeInBytes|tostring) + " bytes)"' || true
          
          # Download standard WASM build artifacts
          echo "Downloading wasm-modules..."
          if ! gh run download "$RUN_ID" --name wasm-modules --dir ci-artifacts/wasm-modules; then
            echo "‚ùå ERROR: Failed to download 'wasm-modules' artifact"
            echo "Available artifacts:"
            gh run view "$RUN_ID" --json artifacts --jq '.artifacts[].name' || true
            exit 1
          fi
          
          # Download Perfetto WASM build artifacts
          echo "Downloading wasm-perfetto-modules..."
          if ! gh run download "$RUN_ID" --name wasm-perfetto-modules --dir ci-artifacts/wasm-perfetto-modules; then
            echo "‚ùå ERROR: Failed to download 'wasm-perfetto-modules' artifact"
            echo "Available artifacts:"
            gh run view "$RUN_ID" --json artifacts --jq '.artifacts[].name' || true
            exit 1
          fi
          
          echo "‚úÖ Successfully downloaded all artifacts"
          echo "üìÅ Downloaded artifact contents:"
          ls -lR ci-artifacts
          
          # Verify required files exist and have reasonable sizes
          echo "üîç Verifying artifact contents..."
          REQUIRED_FILES=(
            "ci-artifacts/wasm-modules/musashi-universal.out.wasm"
            "ci-artifacts/wasm-modules/musashi-universal.out.mjs"
            "ci-artifacts/wasm-perfetto-modules/musashi-universal.out.wasm"
            "ci-artifacts/wasm-perfetto-modules/musashi-universal.out.mjs"
          )
          
          for file in "${REQUIRED_FILES[@]}"; do
            if [ ! -f "$file" ]; then
              echo "‚ùå ERROR: Required file missing: $file"
              exit 1
            fi
            
            size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "0")
            if [ "$size" -lt 10000 ]; then  # Minimum reasonable size
              echo "‚ùå ERROR: File too small (likely corrupt): $file ($size bytes)"
              exit 1
            fi
            
            echo "‚úÖ $file ($size bytes)"
          done

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - name: Prepare npm package from CI artifacts
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p npm-package/dist

          # Stage default build from wasm-modules (Universal variant for both Node.js and browsers, ESM)
          echo "Staging standard WASM build (Universal ESM)..."
          cp ci-artifacts/wasm-modules/musashi-universal.out.wasm npm-package/dist/musashi.wasm
          cp ci-artifacts/wasm-modules/musashi-universal.out.mjs  npm-package/dist/musashi-loader.mjs

          # Stage Perfetto build from wasm-perfetto-modules (Universal variant for both Node.js and browsers, ESM)
          echo "Staging Perfetto WASM build (Universal ESM)..."
          cp ci-artifacts/wasm-perfetto-modules/musashi-universal.out.wasm npm-package/dist/musashi-perfetto.wasm
          cp ci-artifacts/wasm-perfetto-modules/musashi-universal.out.mjs  npm-package/dist/musashi-perfetto-loader.mjs

          # Stage Node-specific build from wasm-modules (Node-targeted ESM)
          echo "Staging Node-specific WASM build (Node ESM)..."
          cp ci-artifacts/wasm-modules/musashi-node.out.mjs  npm-package/musashi-node.out.mjs
          cp ci-artifacts/wasm-modules/musashi-node.out.wasm npm-package/musashi-node.out.wasm

          if [ -f ci-artifacts/wasm-modules/musashi-node.out.wasm.map ]; then
            cp ci-artifacts/wasm-modules/musashi-node.out.wasm.map npm-package/musashi-node.out.wasm.map
          fi

          # Verify all files are present
          echo "Verifying staged files..."
          for file in musashi.wasm musashi-loader.mjs musashi-perfetto.wasm musashi-perfetto-loader.mjs; do
            if [ ! -f "npm-package/dist/$file" ]; then
              echo "ERROR: Missing required file: $file"
              exit 1
            fi
            echo "‚úì $file ($(stat -c%s "npm-package/dist/$file") bytes)"
          done

          echo "Verifying Node-specific files..."
          for file in musashi-node.out.mjs musashi-node.out.wasm; do
            if [ ! -f "npm-package/$file" ]; then
              echo "ERROR: Missing required file: $file"
              exit 1
            fi
            echo "‚úì $file ($(stat -c%s "npm-package/$file") bytes)"
          done

          if [ -f npm-package/musashi-node.out.wasm.map ]; then
            echo "‚úì musashi-node.out.wasm.map ($(stat -c%s "npm-package/musashi-node.out.wasm.map") bytes)"
          else
            echo "‚ÑπÔ∏è musashi-node.out.wasm.map not provided (optional)"
          fi

          # Validate and set version
          VERSION_RAW='${{ steps.validate.outputs.tag }}'
          VERSION="${VERSION_RAW#v}"
          echo "üìã Package version: $VERSION"
          
          # Validate version format
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
            echo "‚ùå ERROR: Invalid version format: $VERSION"
            exit 1
          fi

          cat > npm-package/package.json <<'JSON'
          {
            "name": "musashi-wasm",
            "version": "0.0.0",
            "description": "M68k Musashi WebAssembly (default, Node, and Perfetto profiling builds)",
            "license": "MIT",
            "author": "mblsha",
            "repository": {
              "type": "git",
              "url": "git+https://github.com/mblsha/musashi-wasm.git"
            },
            "keywords": [
              "m68k",
              "68000",
              "motorola",
              "emulator",
              "wasm",
              "webassembly",
              "perfetto",
              "tracing"
            ],
            "type": "module",
            "exports": {
              ".": {
                "import": "./index.mjs"
              },
              "./perf": {
                "import": "./perf.mjs"
              },
              "./node": {
                "import": "./musashi-node.out.mjs"
              },
              "./musashi-node.out.mjs": "./musashi-node.out.mjs",
              "./musashi-node.out.wasm": "./musashi-node.out.wasm"
            },
            "main": "./index.mjs",
            "files": [
              "dist/*",
              "index.mjs",
              "perf.mjs",
              "musashi-node.out.mjs",
              "musashi-node.out.wasm",
              "README.md",
              "LICENSE"
            ],
            "publishConfig": {
              "access": "public",
              "provenance": true
            }
          }
          JSON

          # ESM wrapper for standard build
          cat > npm-package/index.mjs <<'JS'
          import { fileURLToPath } from "url";
          import createModule from "./dist/musashi-loader.mjs";
          
          export default function init(options = {}) {
            const isNode = typeof process !== "undefined" && !!process.versions?.node;
            const wasmUrl = new URL("./dist/musashi.wasm", import.meta.url);
            const wasmPath = isNode ? fileURLToPath(wasmUrl) : wasmUrl.href;
            const locateFile = (p) => p.endsWith(".wasm") ? wasmPath : p;
            return createModule({ locateFile, ...options });
          }
          JS

          # ESM wrapper for Perfetto build
          cat > npm-package/perf.mjs <<'JS'
          import { fileURLToPath } from "url";
          import createModule from "./dist/musashi-perfetto-loader.mjs";
          
          export default function init(options = {}) {
            const isNode = typeof process !== "undefined" && !!process.versions?.node;
            const wasmUrl = new URL("./dist/musashi-perfetto.wasm", import.meta.url);
            const wasmPath = isNode ? fileURLToPath(wasmUrl) : wasmUrl.href;
            const locateFile = (p) => p.endsWith(".wasm") ? wasmPath : p;
            return createModule({ locateFile, ...options });
          }
          JS

          # Copy documentation files if present
          [ -f README.md ] && cp README.md npm-package/ || true
          [ -f LICENSE ]   && cp LICENSE   npm-package/ || true

          # Set the version from the tag
          npm --prefix npm-package version "$VERSION" --no-git-tag-version
          
          echo "Prepared npm package structure:"
          ls -lR npm-package

      - name: Verify package integrity
        working-directory: npm-package
        run: |
          echo "Running npm pack dry-run to verify package..."
          npm pack --dry-run
          echo "Package verification successful!"

      - name: Publish to npm
        working-directory: npm-package
        run: |
          echo "üöÄ Publishing to npm..."
          echo "Package: $(cat package.json | jq -r '.name + "@" + .version')"
          
          # Check if this version already exists
          PACKAGE_NAME=$(cat package.json | jq -r '.name')
          PACKAGE_VERSION=$(cat package.json | jq -r '.version')
          
          if npm view "$PACKAGE_NAME@$PACKAGE_VERSION" version >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Package $PACKAGE_NAME@$PACKAGE_VERSION already exists on npm"
            echo "Skipping publish (this is not an error for re-runs)"
            exit 0
          fi
          
          npm publish --access public --provenance
          echo "‚úÖ Successfully published $PACKAGE_NAME@$PACKAGE_VERSION to npm!"
          
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          
      - name: Report success
        if: success()
        run: |
          echo "üéâ NPM package published successfully!"
          echo "Release: ${{ steps.validate.outputs.tag }}"
          echo "Commit: ${{ steps.validate.outputs.commit }}"
          echo "CI Run: ${{ steps.find_run.outputs.run_id }}"
          echo "Package: $(cat npm-package/package.json | jq -r '.name + "@" + .version')"
          
      - name: Report failure details
        if: failure()
        run: |
          echo "‚ùå NPM publish workflow failed"
          echo "Release: ${{ github.event.release.tag_name || inputs.tag_name }}"
          echo "Please check the logs above for specific error details"
          echo "Common issues:"
          echo "  - WebAssembly CI not completed or failed"
          echo "  - Missing NPM_TOKEN secret"
          echo "  - Package version already exists"
          echo "  - Network/registry issues"
