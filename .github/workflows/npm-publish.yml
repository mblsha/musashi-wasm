name: Publish to npm (reuse CI artifacts)

on:
  release:
    types: [published]
  workflow_dispatch:

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write   # provenance for npm
      actions: read     # allow reading other runs/artifacts
    env:
      GH_TOKEN: ${{ github.token }}   # for gh CLI

    steps:
      - name: Checkout repo at release tag
        uses: actions/checkout@v4
        with:
          submodules: recursive
          ref: ${{ github.event.release.tag_name }}

      - name: Resolve CI run that built this tag
        id: find_run
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ github.event.release.tag_name }}"
          # Commit SHA pointed to by the tag we checked out:
          COMMIT="$(git rev-parse HEAD)"
          echo "Tag: $TAG"
          echo "Commit: $COMMIT"

          # Find a successful run of the 'WebAssembly CI' workflow for this commit
          # Limit to a reasonable window; adjust --limit if you have many runs.
          gh run list --workflow "WebAssembly CI" --json databaseId,headSha,conclusion,event --limit 50 > runs.json
          RUN_ID=$(jq -r --arg sha "$COMMIT" '.[] | select(.headSha==$sha and .conclusion=="success") | .databaseId' runs.json | head -n1)
          if [ -z "$RUN_ID" ] || [ "$RUN_ID" = "null" ]; then
            echo "No successful 'WebAssembly CI' run found for commit $COMMIT"
            echo "Make sure WebAssembly CI runs on tags (v*) and artifacts are retained."
            exit 1
          fi
          echo "Found successful CI run: $RUN_ID"
          echo "run_id=$RUN_ID" >> "$GITHUB_OUTPUT"

      - name: Download CI artifacts for this run
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ci-artifacts
          echo "Downloading artifacts from run ${{ steps.find_run.outputs.run_id }}..."
          
          # Download standard WASM build artifacts
          gh run download "${{ steps.find_run.outputs.run_id }}" --name wasm-modules --dir ci-artifacts/wasm-modules || { 
            echo "ERROR: Missing 'wasm-modules' artifact"
            echo "This usually means the WebAssembly CI workflow didn't complete successfully"
            exit 1
          }
          
          # Download Perfetto WASM build artifacts
          gh run download "${{ steps.find_run.outputs.run_id }}" --name wasm-perfetto-modules --dir ci-artifacts/wasm-perfetto-modules || { 
            echo "ERROR: Missing 'wasm-perfetto-modules' artifact"
            echo "This usually means the Perfetto build in WebAssembly CI didn't complete successfully"
            exit 1
          }
          
          echo "Downloaded artifacts:"
          ls -lR ci-artifacts

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - name: Prepare npm package from CI artifacts
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p npm-package/dist

          # Stage default build from wasm-modules (Node variant, ESM)
          echo "Staging standard WASM build (ESM)..."
          cp ci-artifacts/wasm-modules/musashi-node.out.wasm npm-package/dist/musashi.wasm
          cp ci-artifacts/wasm-modules/musashi-node.out.mjs  npm-package/dist/musashi-loader.mjs

          # Stage Perfetto build from wasm-perfetto-modules (Node variant, ESM)
          echo "Staging Perfetto WASM build (ESM)..."
          cp ci-artifacts/wasm-perfetto-modules/musashi-node.out.wasm npm-package/dist/musashi-perfetto.wasm
          cp ci-artifacts/wasm-perfetto-modules/musashi-node.out.mjs  npm-package/dist/musashi-perfetto-loader.mjs

          # Verify all files are present
          echo "Verifying staged files..."
          for file in musashi.wasm musashi-loader.mjs musashi-perfetto.wasm musashi-perfetto-loader.mjs; do
            if [ ! -f "npm-package/dist/$file" ]; then
              echo "ERROR: Missing required file: $file"
              exit 1
            fi
            echo "✓ $file ($(stat -c%s "npm-package/dist/$file") bytes)"
          done

          # Generate manifest & wrappers (ESM + CJS)
          VERSION_RAW='${{ github.event.release.tag_name }}'
          VERSION="${VERSION_RAW#v}"
          echo "Package version: $VERSION"

          cat > npm-package/package.json <<'JSON'
          {
            "name": "musashi-wasm",
            "version": "0.0.0",
            "description": "M68k Musashi WebAssembly (default and Perfetto profiling builds)",
            "license": "MIT",
            "author": "mblsha",
            "repository": {
              "type": "git",
              "url": "git+https://github.com/mblsha/musashi-wasm.git"
            },
            "keywords": [
              "m68k",
              "68000",
              "motorola",
              "emulator",
              "wasm",
              "webassembly",
              "perfetto",
              "tracing"
            ],
            "type": "module",
            "exports": {
              ".": {
                "import": "./index.mjs"
              },
              "./perf": {
                "import": "./perf.mjs"
              }
            },
            "main": "./index.mjs",
            "files": [
              "dist/*",
              "index.mjs",
              "perf.mjs",
              "README.md",
              "LICENSE"
            ],
            "publishConfig": {
              "access": "public",
              "provenance": true
            }
          }
          JSON

          # ESM wrapper for standard build
          cat > npm-package/index.mjs <<'JS'
          import { fileURLToPath } from "url";
          import createModule from "./dist/musashi-loader.mjs";
          
          export default function init(options = {}) {
            const isNode = typeof process !== "undefined" && !!process.versions?.node;
            const wasmUrl = new URL("./dist/musashi.wasm", import.meta.url);
            const wasmPath = isNode ? fileURLToPath(wasmUrl) : wasmUrl.href;
            const locateFile = (p) => p.endsWith(".wasm") ? wasmPath : p;
            return createModule({ locateFile, ...options });
          }
          JS

          # ESM wrapper for Perfetto build
          cat > npm-package/perf.mjs <<'JS'
          import { fileURLToPath } from "url";
          import createModule from "./dist/musashi-perfetto-loader.mjs";
          
          export default function init(options = {}) {
            const isNode = typeof process !== "undefined" && !!process.versions?.node;
            const wasmUrl = new URL("./dist/musashi-perfetto.wasm", import.meta.url);
            const wasmPath = isNode ? fileURLToPath(wasmUrl) : wasmUrl.href;
            const locateFile = (p) => p.endsWith(".wasm") ? wasmPath : p;
            return createModule({ locateFile, ...options });
          }
          JS

          # Copy documentation files if present
          [ -f README.md ] && cp README.md npm-package/ || true
          [ -f LICENSE ]   && cp LICENSE   npm-package/ || true

          # Set the version from the tag
          npm --prefix npm-package version "$VERSION" --no-git-tag-version
          
          echo "Prepared npm package structure:"
          ls -lR npm-package

      - name: Verify package integrity
        working-directory: npm-package
        run: |
          echo "Running npm pack dry-run to verify package..."
          npm pack --dry-run
          echo "Package verification successful!"

      - name: Publish to npm
        working-directory: npm-package
        run: |
          echo "Publishing to npm..."
          npm publish --access public --provenance
          echo "✅ Successfully published to npm!"
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
