name: Publish to npm (reuse CI artifacts)

on:
  release:
    types: [published]
  push:
    tags:
      - 'v*'

# Prevent concurrent runs that could interfere with each other
concurrency:
  group: npm-publish-${{ github.ref }}
  cancel-in-progress: false

jobs:
  publish:
    runs-on: ubuntu-latest
    if: ${{ startsWith(github.ref, 'refs/tags/') }}
    permissions:
      contents: read
      id-token: write   # provenance for npm
      actions: read     # allow reading other runs/artifacts
    env:
      GH_TOKEN: ${{ github.token }}   # for gh CLI
    timeout-minutes: 15  # Prevent hanging workflows

    steps:
      - name: Checkout repo at release tag
        uses: actions/checkout@v4
        with:
          submodules: recursive
          ref: ${{ github.ref }}

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Validate release and tag
        id: validate
        shell: bash
        run: |
          set -euo pipefail
          TAG="$GITHUB_REF_NAME"
          if [ -z "$TAG" ]; then
            TAG="${GITHUB_REF##*/}"
          fi
          COMMIT="$(git rev-parse HEAD)"
          
          echo "Tag: $TAG"
          echo "Commit: $COMMIT"
          
          # Validate tag format (should be semantic version)
          if [[ ! "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
            echo "ERROR: Tag '$TAG' does not follow semantic versioning format (v1.2.3 or v1.2.3-alpha.1)"
            exit 1
          fi
          
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "commit=$COMMIT" >> "$GITHUB_OUTPUT"
          
      - name: Wait for and resolve CI run
        id: find_run
        shell: bash
        run: |
          set -euo pipefail
          COMMIT="${{ steps.validate.outputs.commit }}"
          TAG="${{ steps.validate.outputs.tag }}"
          
          echo "Looking for successful WebAssembly CI run for commit: $COMMIT"
          
          # Wait for CI to complete with retries (max 10 minutes)
          MAX_ATTEMPTS=20
          WAIT_SECONDS=30
          
          for attempt in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $attempt/$MAX_ATTEMPTS: Searching for successful CI run..."
            
            # Search for successful runs, increasing limit over time
            SEARCH_LIMIT=$((25 + attempt * 5))
            gh run list --workflow "WebAssembly CI" --json databaseId,headSha,conclusion,event,createdAt --limit $SEARCH_LIMIT > runs.json
            
            # Debug: show what we found
            echo "Found runs for this commit:"
            jq -r --arg sha "$COMMIT" '.[] | select(.headSha==$sha) | "  Run " + (.databaseId|tostring) + ": " + .conclusion + " (" + .event + ")"' runs.json || true
            
            # Look for successful run
            RUN_ID=$(jq -r --arg sha "$COMMIT" '.[] | select(.headSha==$sha and .conclusion=="success") | .databaseId' runs.json | head -n1)
            
            if [ -n "$RUN_ID" ] && [ "$RUN_ID" != "null" ]; then
              echo "‚úÖ Found successful CI run: $RUN_ID"
              echo "run_id=$RUN_ID" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            
            # Check if there are any failed runs
            FAILED_COUNT=$(jq -r --arg sha "$COMMIT" '[.[] | select(.headSha==$sha and .conclusion=="failure")] | length' runs.json)
            if [ "$FAILED_COUNT" -gt 0 ]; then
              echo "‚ö†Ô∏è  Found $FAILED_COUNT failed CI run(s) for this commit"
            fi
            
            if [ $attempt -lt $MAX_ATTEMPTS ]; then
              echo "No successful run found yet, waiting ${WAIT_SECONDS}s before retry..."
              sleep $WAIT_SECONDS
            fi
          done
          
          echo "‚ùå TIMEOUT: No successful 'WebAssembly CI' run found for commit $COMMIT after $MAX_ATTEMPTS attempts"
          echo "Please check:"
          echo "  1. WebAssembly CI workflow is configured to run on tags (v*)"
          echo "  2. The CI run completed successfully"
          echo "  3. Artifacts are being retained (retention-days > 0)"
          echo "  4. There are no failures in the WebAssembly CI workflow"
          exit 1

      - name: Download and verify CI artifacts
        shell: bash
        run: |
          set -euo pipefail
          RUN_ID="${{ steps.find_run.outputs.run_id }}"
          mkdir -p ci-artifacts
          
          echo "üì¶ Downloading artifacts from CI run: $RUN_ID"
          
          # List available artifacts first for debugging
          echo "Available artifacts for this run:"
          gh run view "$RUN_ID" --json artifacts --jq '.artifacts[] | "  " + .name + " (" + (.sizeInBytes|tostring) + " bytes)"' || true
          
          # Download standard WASM build artifacts
          echo "Downloading wasm-modules..."
          if ! gh run download "$RUN_ID" --name wasm-modules --dir ci-artifacts/wasm-modules; then
            echo "‚ùå ERROR: Failed to download 'wasm-modules' artifact"
            echo "Available artifacts:"
            gh run view "$RUN_ID" --json artifacts --jq '.artifacts[].name' || true
            exit 1
          fi
          
          # Download Perfetto WASM build artifacts
          echo "Downloading wasm-perfetto-modules..."
          if ! gh run download "$RUN_ID" --name wasm-perfetto-modules --dir ci-artifacts/wasm-perfetto-modules; then
            echo "‚ùå ERROR: Failed to download 'wasm-perfetto-modules' artifact"
            echo "Available artifacts:"
            gh run view "$RUN_ID" --json artifacts --jq '.artifacts[].name' || true
            exit 1
          fi
          
          echo "‚úÖ Successfully downloaded all artifacts"
          echo "üìÅ Downloaded artifact contents:"
          ls -lR ci-artifacts
          
          # Verify required files exist and have reasonable sizes
          echo "üîç Verifying artifact contents..."
          REQUIRED_FILES=(
            "ci-artifacts/wasm-modules/musashi-universal.out.wasm"
            "ci-artifacts/wasm-modules/musashi-universal.out.mjs"
            "ci-artifacts/wasm-modules/musashi-node.out.wasm"
            "ci-artifacts/wasm-modules/musashi-node.out.mjs"
            "ci-artifacts/wasm-perfetto-modules/musashi-universal.out.wasm"
            "ci-artifacts/wasm-perfetto-modules/musashi-universal.out.mjs"
          )
          
          for file in "${REQUIRED_FILES[@]}"; do
            if [ ! -f "$file" ]; then
              echo "‚ùå ERROR: Required file missing: $file"
              exit 1
            fi
            
            size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "0")
            if [ "$size" -lt 10000 ]; then  # Minimum reasonable size
              echo "‚ùå ERROR: File too small (likely corrupt): $file ($size bytes)"
              exit 1
            fi
            
            echo "‚úÖ $file ($size bytes)"
          done

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - name: Install workspace dependencies
        run: npm ci --workspaces --include-workspace-root

      - name: Build core runtime
        run: npm run build --workspace=@m68k/core

      - name: Prepare npm package from CI artifacts
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p npm-package/dist

          # Stage default build from wasm-modules (Universal variant for both Node.js and browsers, ESM)
          echo "Staging standard WASM build (Universal ESM)..."
          cp ci-artifacts/wasm-modules/musashi-universal.out.wasm npm-package/dist/musashi.wasm
          cp ci-artifacts/wasm-modules/musashi-universal.out.mjs  npm-package/dist/musashi-loader.mjs

          # Stage Perfetto build from wasm-perfetto-modules (Universal variant for both Node.js and browsers, ESM)
          echo "Staging Perfetto WASM build (Universal ESM)..."
          cp ci-artifacts/wasm-perfetto-modules/musashi-universal.out.wasm npm-package/dist/musashi-perfetto.wasm
          cp ci-artifacts/wasm-perfetto-modules/musashi-universal.out.mjs  npm-package/dist/musashi-perfetto-loader.mjs

          # Stage Node-specific build from wasm-modules (Node-targeted ESM)
          echo "Staging Node-specific WASM build (Node ESM)..."
          cp ci-artifacts/wasm-modules/musashi-node.out.mjs  npm-package/musashi-node.out.mjs
          cp ci-artifacts/wasm-modules/musashi-node.out.wasm npm-package/musashi-node.out.wasm

          if [ -f ci-artifacts/wasm-modules/musashi-node.out.wasm.map ]; then
            cp ci-artifacts/wasm-modules/musashi-node.out.wasm.map npm-package/musashi-node.out.wasm.map
          fi

          echo "Verifying staged WASM artifacts..."
          for file in musashi.wasm musashi-loader.mjs musashi-perfetto.wasm musashi-perfetto-loader.mjs; do
            if [ ! -f "npm-package/dist/$file" ]; then
              echo "ERROR: Missing required file: $file"
              exit 1
            fi
            echo "‚úì $file ($(stat -c%s "npm-package/dist/$file") bytes)"
          done

          for file in musashi-node.out.mjs musashi-node.out.wasm; do
            if [ ! -f "npm-package/$file" ]; then
              echo "ERROR: Missing required file: $file"
              exit 1
            fi
            echo "‚úì $file ($(stat -c%s "npm-package/$file") bytes)"
          done

          if [ -f npm-package/musashi-node.out.wasm.map ]; then
            echo "‚úì musashi-node.out.wasm.map ($(stat -c%s "npm-package/musashi-node.out.wasm.map") bytes)"
          fi

          echo "Syncing wasm artifacts into lib/wasm..."
          mkdir -p npm-package/lib/wasm
          cp ci-artifacts/wasm-modules/musashi.out.mjs npm-package/lib/wasm/musashi.out.mjs
          cp ci-artifacts/wasm-modules/musashi.out.wasm npm-package/lib/wasm/musashi.out.wasm
          cp ci-artifacts/wasm-modules/musashi-universal.out.mjs npm-package/lib/wasm/musashi-universal.out.mjs
          cp ci-artifacts/wasm-modules/musashi-universal.out.wasm npm-package/lib/wasm/musashi-universal.out.wasm
          cp ci-artifacts/wasm-modules/musashi-node.out.mjs npm-package/lib/wasm/musashi-node.out.mjs
          cp ci-artifacts/wasm-modules/musashi-node.out.wasm npm-package/lib/wasm/musashi-node.out.wasm
          if [ -f ci-artifacts/wasm-modules/musashi-node.out.wasm.map ]; then
            cp ci-artifacts/wasm-modules/musashi-node.out.wasm.map npm-package/lib/wasm/musashi-node.out.wasm.map
          fi

          echo "Ensuring musashi-wasm/node typings are present..."
          cat <<'EOF' > npm-package/musashi-node.d.ts
declare module 'musashi-wasm/node' {
  export interface MusashiNodeInitOptions {
    locateFile?: (path: string, prefix?: string) => string;
    [key: string]: unknown;
  }

  export type MusashiNodeFactory = (options?: MusashiNodeInitOptions) => Promise<unknown>;

  const init: MusashiNodeFactory;

  export default init;
}
EOF

          echo "Rebuilding npm-package wrapper to stage core runtime..."
          npm --prefix npm-package run build

          echo "Validating bundled core runtime..."
          for file in lib/core/index.js lib/core/index.d.ts lib/wasm/musashi-node-wrapper.mjs; do
            if [ ! -f "npm-package/$file" ]; then
              echo "ERROR: Missing required file: $file"
              exit 1
            fi
          done

          [ -f README.md ] && cp README.md npm-package/ || true
          [ -f LICENSE ]   && cp LICENSE   npm-package/ || true

          VERSION_RAW='${{ steps.validate.outputs.tag }}'
          VERSION="${VERSION_RAW#v}"
          echo "üìã Package version: $VERSION"

          npm --prefix npm-package version "$VERSION" --no-git-tag-version

          echo "Prepared npm package structure:"
          ls -lR npm-package

      - name: Verify package integrity
        working-directory: npm-package
        run: |
          echo "Running npm pack dry-run to verify package..."
          npm pack --dry-run
          echo "Package verification successful!"

      - name: Publish to npm
        working-directory: npm-package
        run: |
          echo "üöÄ Publishing to npm..."
          echo "Package: $(cat package.json | jq -r '.name + "@" + .version')"
          
          # Check if this version already exists
          PACKAGE_NAME=$(cat package.json | jq -r '.name')
          PACKAGE_VERSION=$(cat package.json | jq -r '.version')
          
          if npm view "$PACKAGE_NAME@$PACKAGE_VERSION" version >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Package $PACKAGE_NAME@$PACKAGE_VERSION already exists on npm"
            echo "Skipping publish (this is not an error for re-runs)"
            exit 0
          fi
          
          npm publish --access public --provenance
          echo "‚úÖ Successfully published $PACKAGE_NAME@$PACKAGE_VERSION to npm!"
          
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          
      - name: Report success
        if: success()
        run: |
          echo "üéâ NPM package published successfully!"
          echo "Release: ${{ steps.validate.outputs.tag }}"
          echo "Commit: ${{ steps.validate.outputs.commit }}"
          echo "CI Run: ${{ steps.find_run.outputs.run_id }}"
          echo "Package: $(cat npm-package/package.json | jq -r '.name + "@" + .version')"
          
      - name: Report failure details
        if: failure()
        run: |
          echo "‚ùå NPM publish workflow failed"
          echo "Release: ${GITHUB_REF_NAME:-${GITHUB_REF##*/}}"
          echo "Please check the logs above for specific error details"
          echo "Common issues:"
          echo "  - WebAssembly CI not completed or failed"
          echo "  - Missing NPM_TOKEN secret"
          echo "  - Package version already exists"
          echo "  - Network/registry issues"
